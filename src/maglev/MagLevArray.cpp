// Generated by Haxe 4.1.1
#include <hxcpp.h>

#ifndef INCLUDED_maglev_MagLevAny
#include <maglev/MagLevAny.h>
#endif
#ifndef INCLUDED_maglev_MagLevArray
#include <maglev/MagLevArray.h>
#endif
#ifndef INCLUDED_maglev_MagLevNull
#include <maglev/MagLevNull.h>
#endif
#ifndef INCLUDED_maglev_MagLevString
#include <maglev/MagLevString.h>
#endif
#ifndef INCLUDED_maglev__MagLevTypes_MagLevType_Impl_
#include <maglev/_MagLevTypes/MagLevType_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_bfc328c39f1c1463_307_new,"maglev.MagLevArray","new",0x659f253d,"maglev.MagLevArray.new","maglev/MagLevTypes.hx",307,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_312_size,"maglev.MagLevArray","size",0x88f28d44,"maglev.MagLevArray.size","maglev/MagLevTypes.hx",312,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_315_pop,"maglev.MagLevArray","pop",0x65a0b26e,"maglev.MagLevArray.pop","maglev/MagLevTypes.hx",315,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_317_push,"maglev.MagLevArray","push",0x86fffe5d,"maglev.MagLevArray.push","maglev/MagLevTypes.hx",317,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_322_shift,"maglev.MagLevArray","shift",0x4a92f29f,"maglev.MagLevArray.shift","maglev/MagLevTypes.hx",322,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_325_unshift,"maglev.MagLevArray","unshift",0xc7c76ae6,"maglev.MagLevArray.unshift","maglev/MagLevTypes.hx",325,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_328_reverse,"maglev.MagLevArray","reverse",0x6a0fc07f,"maglev.MagLevArray.reverse","maglev/MagLevTypes.hx",328,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_331_get,"maglev.MagLevArray","get",0x6599d573,"maglev.MagLevArray.get","maglev/MagLevTypes.hx",331,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_334_set,"maglev.MagLevArray","set",0x65a2f07f,"maglev.MagLevArray.set","maglev/MagLevTypes.hx",334,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_337_getType,"maglev.MagLevArray","getType",0x6e9f29cd,"maglev.MagLevArray.getType","maglev/MagLevTypes.hx",337,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_340_isEqual,"maglev.MagLevArray","isEqual",0x5e1bfac7,"maglev.MagLevArray.isEqual","maglev/MagLevTypes.hx",340,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_363_toJson,"maglev.MagLevArray","toJson",0x4fb70086,"maglev.MagLevArray.toJson","maglev/MagLevTypes.hx",363,0x03b0b9b4)
HX_LOCAL_STACK_FRAME(_hx_pos_bfc328c39f1c1463_305_create,"maglev.MagLevArray","create",0x4fa4ba3f,"maglev.MagLevArray.create","maglev/MagLevTypes.hx",305,0x03b0b9b4)
namespace maglev{

void MagLevArray_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_307_new)
HXLINE( 308)		this->values = ::Array_obj< ::Dynamic>::__new();
HXLINE( 309)		super::__construct();
            	}

Dynamic MagLevArray_obj::__CreateEmpty() { return new MagLevArray_obj; }

void *MagLevArray_obj::_hx_vtable = 0;

Dynamic MagLevArray_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< MagLevArray_obj > _hx_result = new MagLevArray_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool MagLevArray_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x48ac5325) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x48ac5325;
	} else {
		return inClassId==(int)0x7fdb9bc4;
	}
}

int MagLevArray_obj::size(){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_312_size)
HXDLIN( 312)		return this->values->length;
            	}


HX_DEFINE_DYNAMIC_FUNC0(MagLevArray_obj,size,return )

 ::maglev::MagLevAny MagLevArray_obj::pop(){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_315_pop)
HXDLIN( 315)		return ::maglev::MagLevNull_obj::wrap(this->values->pop().StaticCast<  ::maglev::MagLevAny >());
            	}


HX_DEFINE_DYNAMIC_FUNC0(MagLevArray_obj,pop,return )

int MagLevArray_obj::push( ::maglev::MagLevAny x){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_317_push)
HXLINE( 318)		this->values->push(x);
HXLINE( 319)		return this->size();
            	}


HX_DEFINE_DYNAMIC_FUNC1(MagLevArray_obj,push,return )

 ::maglev::MagLevAny MagLevArray_obj::shift(){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_322_shift)
HXDLIN( 322)		return ::maglev::MagLevNull_obj::wrap(this->values->shift().StaticCast<  ::maglev::MagLevAny >());
            	}


HX_DEFINE_DYNAMIC_FUNC0(MagLevArray_obj,shift,return )

void MagLevArray_obj::unshift( ::maglev::MagLevAny x){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_325_unshift)
HXDLIN( 325)		::Array< ::Dynamic> _hx_tmp = this->values;
HXDLIN( 325)		_hx_tmp->unshift(::maglev::MagLevNull_obj::wrap(x));
            	}


HX_DEFINE_DYNAMIC_FUNC1(MagLevArray_obj,unshift,(void))

void MagLevArray_obj::reverse(){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_328_reverse)
HXDLIN( 328)		this->values->reverse();
            	}


HX_DEFINE_DYNAMIC_FUNC0(MagLevArray_obj,reverse,(void))

 ::maglev::MagLevAny MagLevArray_obj::get(int i){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_331_get)
HXDLIN( 331)		return ::maglev::MagLevNull_obj::wrap(this->values->__get(i).StaticCast<  ::maglev::MagLevAny >());
            	}


HX_DEFINE_DYNAMIC_FUNC1(MagLevArray_obj,get,return )

void MagLevArray_obj::set(int i, ::maglev::MagLevAny value){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_334_set)
HXDLIN( 334)		this->values[i] = ::maglev::MagLevNull_obj::wrap(value);
            	}


HX_DEFINE_DYNAMIC_FUNC2(MagLevArray_obj,set,(void))

int MagLevArray_obj::getType(){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_337_getType)
HXDLIN( 337)		return ::maglev::_MagLevTypes::MagLevType_Impl__obj::MagLevType_Array;
            	}


bool MagLevArray_obj::isEqual( ::maglev::MagLevAny other){
            	HX_STACKFRAME(&_hx_pos_bfc328c39f1c1463_340_isEqual)
HXDLIN( 340)		int _hx_tmp = other->getType();
HXDLIN( 340)		if ((_hx_tmp == this->getType())) {
HXLINE( 341)			 ::maglev::MagLevArray o = ::hx::TCast<  ::maglev::MagLevArray >::cast(other);
HXLINE( 342)			int _hx_tmp = this->size();
HXDLIN( 342)			if ((_hx_tmp == o->size())) {
HXLINE( 343)				 ::maglev::MagLevArray arr = ::hx::TCast<  ::maglev::MagLevArray >::cast(other);
HXLINE( 344)				{
HXLINE( 344)					int _g = 0;
HXDLIN( 344)					::Array< ::Dynamic> _g1 = this->values;
HXDLIN( 344)					while((_g < _g1->length)){
HXLINE( 344)						 ::maglev::MagLevAny item = _g1->__get(_g).StaticCast<  ::maglev::MagLevAny >();
HXDLIN( 344)						_g = (_g + 1);
HXLINE( 345)						bool found = false;
HXLINE( 346)						{
HXLINE( 346)							int _g2 = 0;
HXDLIN( 346)							::Array< ::Dynamic> _g3 = arr->values;
HXDLIN( 346)							while((_g2 < _g3->length)){
HXLINE( 346)								 ::maglev::MagLevAny item2 = _g3->__get(_g2).StaticCast<  ::maglev::MagLevAny >();
HXDLIN( 346)								_g2 = (_g2 + 1);
HXLINE( 347)								if (item->isEqual(item2)) {
HXLINE( 348)									found = true;
            								}
            							}
            						}
HXLINE( 351)						if (!(found)) {
HXLINE( 351)							return false;
            						}
            					}
            				}
HXLINE( 353)				return true;
            			}
            			else {
HXLINE( 356)				return false;
            			}
            		}
            		else {
HXLINE( 360)			return false;
            		}
HXLINE( 340)		return false;
            	}


 ::maglev::MagLevString MagLevArray_obj::toJson(){
            	HX_GC_STACKFRAME(&_hx_pos_bfc328c39f1c1463_363_toJson)
HXLINE( 364)		::String s = HX_("[",5b,00,00,00);
HXLINE( 365)		bool first = true;
HXLINE( 366)		{
HXLINE( 366)			int _g = 0;
HXDLIN( 366)			::Array< ::Dynamic> _g1 = this->values;
HXDLIN( 366)			while((_g < _g1->length)){
HXLINE( 366)				 ::maglev::MagLevAny item = _g1->__get(_g).StaticCast<  ::maglev::MagLevAny >();
HXDLIN( 366)				_g = (_g + 1);
HXLINE( 367)				if (!(first)) {
HXLINE( 368)					s = (s + HX_(", ",74,26,00,00));
            				}
HXLINE( 370)				s = (s + item->toJson()->getString());
HXLINE( 371)				first = false;
            			}
            		}
HXLINE( 373)		s = (s + HX_("]",5d,00,00,00));
HXLINE( 374)		return  ::maglev::MagLevString_obj::__alloc( HX_CTX ,s);
            	}


 ::maglev::MagLevArray MagLevArray_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_bfc328c39f1c1463_305_create)
HXDLIN( 305)		return  ::maglev::MagLevArray_obj::__alloc( HX_CTX );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(MagLevArray_obj,create,return )


::hx::ObjectPtr< MagLevArray_obj > MagLevArray_obj::__new() {
	::hx::ObjectPtr< MagLevArray_obj > __this = new MagLevArray_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< MagLevArray_obj > MagLevArray_obj::__alloc(::hx::Ctx *_hx_ctx) {
	MagLevArray_obj *__this = (MagLevArray_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(MagLevArray_obj), true, "maglev.MagLevArray"));
	*(void **)__this = MagLevArray_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

MagLevArray_obj::MagLevArray_obj()
{
}

void MagLevArray_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(MagLevArray);
	HX_MARK_MEMBER_NAME(values,"values");
	HX_MARK_END_CLASS();
}

void MagLevArray_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(values,"values");
}

::hx::Val MagLevArray_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pop") ) { return ::hx::Val( pop_dyn() ); }
		if (HX_FIELD_EQ(inName,"get") ) { return ::hx::Val( get_dyn() ); }
		if (HX_FIELD_EQ(inName,"set") ) { return ::hx::Val( set_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"size") ) { return ::hx::Val( size_dyn() ); }
		if (HX_FIELD_EQ(inName,"push") ) { return ::hx::Val( push_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"shift") ) { return ::hx::Val( shift_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"values") ) { return ::hx::Val( values ); }
		if (HX_FIELD_EQ(inName,"toJson") ) { return ::hx::Val( toJson_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"unshift") ) { return ::hx::Val( unshift_dyn() ); }
		if (HX_FIELD_EQ(inName,"reverse") ) { return ::hx::Val( reverse_dyn() ); }
		if (HX_FIELD_EQ(inName,"getType") ) { return ::hx::Val( getType_dyn() ); }
		if (HX_FIELD_EQ(inName,"isEqual") ) { return ::hx::Val( isEqual_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool MagLevArray_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { outValue = create_dyn(); return true; }
	}
	return false;
}

::hx::Val MagLevArray_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"values") ) { values=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void MagLevArray_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("values",e2,03,b7,4f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo MagLevArray_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(MagLevArray_obj,values),HX_("values",e2,03,b7,4f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *MagLevArray_obj_sStaticStorageInfo = 0;
#endif

static ::String MagLevArray_obj_sMemberFields[] = {
	HX_("values",e2,03,b7,4f),
	HX_("size",c1,a0,53,4c),
	HX_("pop",91,5d,55,00),
	HX_("push",da,11,61,4a),
	HX_("shift",82,ec,22,7c),
	HX_("unshift",89,e3,b3,78),
	HX_("reverse",22,39,fc,1a),
	HX_("get",96,80,4e,00),
	HX_("set",a2,9b,57,00),
	HX_("getType",70,a2,8b,1f),
	HX_("isEqual",6a,73,08,0f),
	HX_("toJson",43,ad,21,7c),
	::String(null()) };

::hx::Class MagLevArray_obj::__mClass;

static ::String MagLevArray_obj_sStaticFields[] = {
	HX_("create",fc,66,0f,7c),
	::String(null())
};

void MagLevArray_obj::__register()
{
	MagLevArray_obj _hx_dummy;
	MagLevArray_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("maglev.MagLevArray",cb,c2,02,ff);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MagLevArray_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(MagLevArray_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(MagLevArray_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< MagLevArray_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MagLevArray_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MagLevArray_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace maglev
